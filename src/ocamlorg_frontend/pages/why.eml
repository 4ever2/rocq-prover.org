let render () =
Layout.render
~title:"Why Rocq?"
~description:"Rocq is a mature, dependently-typed functional programming language and interactive theorem prover. Learn more about what makes it unique."
~canonical:Url.about @@
<div class="lg:-mt-32 lg:pt-44 intro-section-simple dark:dark-intro-section-simple">
  <div class="container-fluid">
    <div class="text-center w-full lg:w-2/3 m-auto">
      <h1 class="font-bold mb-6 text-title dark:text-dark-title">Why Rocq?</h1>
      <div class="flex items-center justify-center space-x-8 mt-11 lg:space-x-24">
        <div>
          <a
            class="hover:text-primary dark:hover:text-dark-primary hover:bg-primary_25 dark:hover:bg-dark-primary_20 rounded-lg h-28 w-28 inline-block transition-colors"
            href="#strengths"
          >
            <%s! Icons.lightning "h-10 w-10 mb-4 m-auto mt-6" %>
            <div class="font-semibold text-lg text-content dark:text-dark-content">Strengths</div>
          </a>
        </div>
        <div>
          <a
            class="hover:text-primary dark:hover:text-dark-primary hover:bg-primary_25 dark:hover:bg-dark-primary_20 h-28 w-28 rounded-lg inline-block transition-colors"
            href="#features"
          >
            <%s! Icons.features "h-10 w-10 mb-4 m-auto mt-6" %>
            <div class="font-semibold text-lg text-content dark:text-dark-content">Features</div>
          </a>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="bg-background dark:bg-dark-background">
  <div class="py-10 lg:py-28">
    <div class="container-fluid">
      <div class="prose dark:prose-invert lg:prose-lg mx-auto max-w-5xl">
        <h2 id="strengths">Strengths</h2>
        <div class="space-y-10">
          <p> 
            The Rocq Prover follows from over 40 years of research in Dependent Type Theory and Interactive Theorem Proving.
            It is based on the Predicative, Polymorphic and Cumulative Calculus of Inductive Constructions (PCUIC), a dependently-typed 
            formal language for constructive mathematics that allows to express complex, higher-order mathematical statements 
            and functional programs. PCUIC includes general schemes for the definition of families of mutual or nested inductive 
            and coinductive types, that can be used to model and program with finite or infinite data structures and predicates. 
            The Calculus of Constructions [<a href="/papers/the-calculus-of-constructions">1988</a>], due to Thierry Coquand and Gérard Huet,
            is a generalization of simply-typed λ-calculus, at the basis of most type theories, 
            with a infinite, predicative and cumulative hierarchy of universes Type@{i} for computational types
            and two impredicative propositional universes, Prop and SProp for proof-irrelevant and definitionally proof-irrelevant 
            propositions. Based on this distinction between computations and proofs, PCUIC supports a well-behaved notion of erasure
            used by its extraction mechanisms, allowing to produce efficient programs in standard programming languages from formal 
            developments. While being based on constructive mathematical foundations, PCUIC also accomodates using classical axioms 
            in its propositional universes without affecting its good theoretical properties. PCUIC supports sort and universe polymorphism
            allowing to write generic definitions depending on universes. Beyond this, the system supports a notion of primitive types 
            including 63-bit integers, IEEE-754 floats, persistent arrays and strings for efficient computation with primitive values.
            The following section details these features in more details.
          </p>
        </div>
        <h2 id="features">Features</h2>
        <div class="space-y-10">
          <ul>
            <li>
              <strong>(Co-)Inductive Type Families, mutual and nested:</strong>
              PCUIC is an evolution of the Calculus of Inductive Constructions introduced by 
              Thierry Coquand and Christine Paulin-Mohring in [<a href="/papers/inductively-defined-types">1988</a>, 
              <a href="/papers/inductive-definitions-in-the-system-coq---rules-and-properties">1993</a>]
              as an extension of the Calculus of Constructions with schemes for inductive types and families.
              Inductive types are a central modeling tool in the language: they allow to represent both computational data structures 
              like natural numbers and lists as well as logical judgments like predicates, relations and typing systems.
              In the Gallina language, inductive types can be consumed by fixpoint computations that are checked to be terminating thanks 
              to a so-called syntactic guard condition. The Rocq tactics allow to perform induction and inversion reasoning on these 
              inductive structures. Co-inductive types and co-recursion are also available to model infinite structures and judgments, 
              like bisimulation relations. A high-level dependent pattern-matching compiler is available through the Equations package
              as part of the Rocq platform.
            </li>
            <li>
              <strong>Universes, Typical Ambiguity, and Implicit Cumulativity</strong>
              The Gallina surface language of the Rocq Prover supports the notion of typical ambiguity for universes,
              going back to the seminal work of Alfred North Whitehead and Bertrand Russell in Principia Mathematica (1910-1913),
              which allows implicit handling of the relation between universes. An anonymous <verb>Type</verb> occurrence 
              represents a <emph>floating</emph> universe variable that can get constrained depending on its use in 
              the rest of the code. The predicative universe hierarchy <verb>Type@{i}</verb> is cumulative, hence uses of 
              universes can results in inclusion constraints, showing that e.g. <verb>Type@{i} <= Type@{j}</verb>.
              The Rocq Prover handles this graph of universes and constraints incrementaly and checks that the 
              universe graph is acyclic at all times, ensuring consistency of the definitions. The user can hence write formal 
              developments without ever needing to annotate universes, letting the Rocq elaboration engine take care of it.
            </li>
            <li>
              <strong>Universe and Sort Polymorphism:</strong>
              Since Rocq 9, both universes and sorts can be abstracted over in inductive types, definitions and proofs.
              This polymorphism allows to share between predicative and impredicative, proof-relevant or proof-irrelevant 
              universes. 
            </li>
            <li>
              <strong>Definitional Proof Irrelevance:</strong>
            </li>
            <li>
              <strong>Efficient Definitional Equality Checkers:</strong>
            </li>
            
            <li>
              <strong>Certified Type Theory and Extraction:</strong>
              The Rocq Prover is based on the formal verification of its type theory implementation and extraction system,
              developed in the <a href="metacoq.github.io">MetaRocq</a> project, which provides an alternative, certified 
              proof checker that minimize the trusted code base and increases user confidence in its results.
            </li>
            <li>
              <strong>Metaprogramming Languages</strong>
              <p class="my-4 font-normal text-lg text-content dark:text-dark-content">                
                The built-in Ltac2 typed tactic programming language enables 
                the design of predictable and comfortable automation for proofs at a high-level of 
                abstraction, with native handling of the proof state and backtracking.
              </p>
              <p class="my-4 font-normal text-lg text-content dark:text-dark-content">
                As part of the Rocq Platform, two alternative languages are available:
                <ul>
                  <li>
                    A low level of abstraction is provided by the MetaRocq project which uses Rocq itself 
                    as the metaprogramming language. It allows directly working with the core term syntax 
                    and prove meta-theorems on the typing judgments of Rocq inside Rocq.
                  </li>
                  <li>
                    An alternative high-level language is provided by Rocq-Elpi, 
                    which interfaces Rocq with λ-prolog, a logic programming language allowing to naturally 
                    express proof-search, unification and elaboration problems. Rocq-Elpi is at the core of 
                    Hierarchy-Builder, a metaprogramming tool that allows the effective development of 
                    hierarchies of structures in Rocq in an entirely declarative fashion. It handles in 
                    particular all structures used in the Mathematical Components libraries.
                  </li>
                </ul>
              </p>
            </li>
          </ul>
        </div>

        <h2 id="features">Future</h2>
        <div class="space-y-10">
          See our <a href="/roadmap">roadmap</a> for upcoming developments improving the Rocq Prover and Platform.
        </div>
      </div>
    </div>
  </div>
</div>
